// This file is automatically generated, please do not alter it.
// 2025-10-27 15:10:18
#pragma once

inline auto STROKE_PASS_COMP_STR =
	"#version 310 es"
	"layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;"
	"struct Stroke"
	"{"
	"    int numCircles;"
	"    int startIndex;"
	"};"
	"struct Circle"
	"{"
	"    vec2 center;"
	"    float radius;"
	"};"
	"layout(binding = 3, std140) uniform LocalInfo"
	"{"
	"    int numStrokes;"
	"    int width;"
	"    int height;"
	"    float aa;"
	"    vec4 strokeColor;"
	"} localInfo;"
	"layout(binding = 1, std430) readonly buffer Strokes"
	"{"
	"    Stroke strokes[];"
	"} _168;"
	"layout(binding = 0, std430) readonly buffer Circles"
	"{"
	"    Circle circles[];"
	"} _196;"
	"layout(binding = 2, rgba32f) uniform writeonly highp image2D outputImage;"
	"float edgeAlpha(float dist, float radius, float aa)"
	"{"
	"    float delta = radius - dist;"
	"    if (delta >= aa)"
	"    {"
	"        return 1.0;"
	"    }"
	"    if (delta <= 0.0)"
	"    {"
	"        return 0.0;"
	"    }"
	"    return delta / aa;"
	"}"
	"vec4 blendMax(vec4 a, vec4 b)"
	"{"
	"    return vec4(max(a.xyz, b.xyz), max(a.w, b.w));"
	"}"
	"vec4 blendAlpha(vec4 src, vec4 dst)"
	"{"
	"    float a = src.w + (dst.w * (1.0 - src.w));"
	"    if (a < 9.9999999747524270787835121154785e-07)"
	"    {"
	"        return vec4(0.0);"
	"    }"
	"    vec3 rgb = ((src.xyz * src.w) + ((dst.xyz * dst.w) * (1.0 - src.w))) / vec3(a);"
	"    return vec4(rgb, a);"
	"}"
	"void main()"
	"{"
	"    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);"
	"    bool _134 = pix.x >= localInfo.width;"
	"    bool _145;"
	"    if (!_134)"
	"    {"
	"        _145 = pix.y >= localInfo.height;"
	"    }"
	"    else"
	"    {"
	"        _145 = _134;"
	"    }"
	"    if (_145)"
	"    {"
	"        return;"
	"    }"
	"    vec4 canvas = vec4(0.0);"
	"    Stroke stroke;"
	"    Circle c;"
	"    for (int s = 0; s < localInfo.numStrokes; s++)"
	"    {"
	"        stroke.numCircles = _168.strokes[s].numCircles;"
	"        stroke.startIndex = _168.strokes[s].startIndex;"
	"        vec4 strokePixel = vec4(0.0);"
	"        for (int i = 0; i < stroke.numCircles; i++)"
	"        {"
	"            int _200 = stroke.startIndex + i;"
	"            c.center = _196.circles[_200].center;"
	"            c.radius = _196.circles[_200].radius;"
	"            vec2 p = vec2(pix) + vec2(0.5);"
	"            float dist = length(p - c.center);"
	"            float param = dist;"
	"            float param_1 = c.radius;"
	"            float param_2 = localInfo.aa;"
	"            float alpha = edgeAlpha(param, param_1, param_2) * localInfo.strokeColor.w;"
	"            if (alpha > 0.0)"
	"            {"
	"                vec4 cCol = vec4(localInfo.strokeColor.xyz, alpha);"
	"                vec4 param_3 = strokePixel;"
	"                vec4 param_4 = cCol;"
	"                strokePixel = blendMax(param_3, param_4);"
	"            }"
	"        }"
	"        vec4 param_5 = strokePixel;"
	"        vec4 param_6 = canvas;"
	"        canvas = blendAlpha(param_5, param_6);"
	"    }"
	"    imageStore(outputImage, pix, canvas);"
	"}"
;