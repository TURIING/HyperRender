#version 450

layout(local_size_x = 16, local_size_y = 16) in;

struct Circle {
    vec2 center;
    float radius;
};

struct Stroke {
    int numCircles;
    int startIndex; // circles 数组起始位置
};

layout(std430, binding=0) readonly buffer Circles {
    Circle circles[];
} circlesBuf;

layout(std430, binding=1) readonly buffer Strokes {
    Stroke strokes[];
} strokesBuf;

layout(rgba8, binding=2) writeonly uniform image2D outputImage;

layout (binding = 3) uniform LocalInfo {
    int numStrokes;
    int width;
    int height;
    float aa;
    vec4 strokeColor; // r,g,b,a
} localInfo;

float edgeAlpha(float dist, float radius, float aa) {
    float delta = radius - dist;
    if(delta >= aa) return 1.0;
    if(delta <= 0.0) return 0.0;
    return delta / aa;
}

vec4 blendMax(vec4 a, vec4 b) {
    return vec4(max(a.rgb, b.rgb), max(a.a, b.a));
}

vec4 blendAlpha(vec4 src, vec4 dst) {
    float a = src.a + dst.a * (1.0 - src.a);
    if(a < 1e-6) return vec4(0.0);
    vec3 rgb = (src.rgb * src.a + dst.rgb * dst.a * (1.0 - src.a)) / a;
    return vec4(rgb, a);
}

void main() {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    if(pix.x >= localInfo.width || pix.y >= localInfo.height) return;

    vec4 canvas = vec4(0.0); // 最终像素

    for(int s=0;s<localInfo.numStrokes;s++){
        Stroke stroke = strokesBuf.strokes[s];
        vec4 strokePixel = vec4(0.0); // 笔画内部 max

        for(int i=0;i<stroke.numCircles;i++){
            Circle c = circlesBuf.circles[stroke.startIndex + i];
            vec2 p = vec2(pix) + 0.5;
            float dist = length(p - c.center);
            float alpha = edgeAlpha(dist, c.radius, localInfo.aa) * localInfo.strokeColor.a;
            if(alpha > 0.0){
                vec4 cCol = vec4(localInfo.strokeColor.rgb, alpha);
                strokePixel = blendMax(strokePixel, cCol); // 笔画内部 max
            }
        }
        // 笔画间 alpha 混合
        canvas = blendAlpha(strokePixel, canvas);
        if(canvas.w == 1.0) break;
    }

    imageStore(outputImage, pix, canvas);
}